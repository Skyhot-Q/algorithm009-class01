# 学习笔记
## 哈希表解决了什么问题
通过关键码值映射到表中的一个位置来访问记录，以加快查找的速度
而 map 和 set 底层都是采用哈希表
这样带来的好处自然有去重、提高查找速度，但就是多一些资源消耗

### 哈希存储
将一个key通过哈希函数进行运算，得出相应的下标值，然后进行对key的存放
而在通过key寻找值时也是同样是通过哈希函数对key进行运算得出相应的下标值，然后查询到值返回
   
### 哈希冲突
通过哈希函数运算有可能出现不同的key出现同一个下标值的现象
为了解决这个问题，通常采用下标的值更换成链表的形式进行存储
在查询时就可以先快速定位到相应的下标位，然后在对链表里值进行遍历比对，得出所需要的值
但是这里也就是代表这查询的复杂度最差会到O(n)

### 哈希的优化
在这个流程可以看出，哈希函数的运算处理速度决定了效率的高低
所以从流程入手，我们可以对key的类型、哈希算法两方面进行优化
key的类型，最好是采用int类型来进行，这样的计算速度是最快的
对于哈希算法的优化的话，个人觉得是需要在实际使用场景中对哈希冲突概率和运算时间做出权衡，从而达到最合适的效果，具体需要参考工业级代码研究。

## 树解决了什么问题
在链表时，查询是O(n)的复杂度
所以为了提高查询的效率，采用"升维"的方式，也就是通过增加类"next"的字段，层层衍生下去，将其变成"树"结构
可以理解，"链表"是特殊化的"树"
但需要注意，节点和节点直接出现环路时，是称为"图"
可以理解，"树"是特殊化的"图"

### 二叉树
二叉树，是表明为1个父节点只会有1～2个子节点的树形状，也就是
```mermaid
graph TB
root -> left 
root -> right
right -> left-1
right -> right-1
```
#### 二叉树遍历方法
前序：根左右
中序：左根右
后序：左右根

对二叉树的代码实现操作，用递归方式是最简单的，因为细分到每个节点的操作，会发现都是重复性的操作
这里需要记住递归的编写方式！

#### 二叉搜索树
具备以下规则的二叉树
1. 左子树所有节点的值均小于它的根节点的值
2. 右子树所有节点的值均大于它的根节点的值
3. 以此类推：左、右子树也分别为二叉搜索树（重复性）

二叉搜索树的查询、插入、删除都是O(logn)的，这比链表要快很多


## 堆解决了什么问题
堆（heap）是可以快速找到一堆数中的最大值或最小值的数据结构
所以在频繁获取最大值和最小值来进行操作的场景中，非常实用

### 堆的分类
如果根节点为最大时叫大顶堆、大根堆
如果根节点为最小时叫小顶堆、小根堆

### 堆的操作复杂度
对于大顶堆来说（小顶堆同理）
find-max: O(1)
delete-max: O(1)
insert(create): O(logN) or O(1)

### 堆是interface！
其实可以理解堆其实时interface，它的本质就是可以满足最基本操作复杂度的需求获取最大值或最小值
所以堆有很多实现方式，可以查看wiki（https://en.wikipedia.org/wiki/Heap_(data_structure)）
最常见的实现方式就是二叉堆，而二叉堆是完全二叉树实现的
完全二叉树并不是二叉搜索树，完全不一样。
完全二叉树就是，每个节点的自节点是满的，也就是都是2个节点，直到没有。

### 二叉堆的实现细节
1. 一般由数组实现
2. 数据规律为 根节点为i时，左节点就是 i*2+1, 右节点就是 i*2+2

### 二叉堆操作细节
插入：插堆尾，向上升，直到不大于父亲
删除：尾换头，向下降，直到堆尾

### Go的heap实现
Go的Container包中的heap实现也是二叉堆，并将操作细节进行了固定化
将一些比较的逻辑大小或者换位置的操作是用了interface的方式让用户自定义
这样很好的兼容了，二叉堆的操作流程固化以及用户数据结构自定义

## 图解决什么问题？
图=点+边
其实图是最好解决关系这一层面的问题，很好的阐述点与点之间的关系，权重、属性

实现图注意时，需要注意环路问题，点记得要记录
 
### 表现形式
领接矩阵表示法
领接链表表示法
